\documentclass{article}
\usepackage[a4paper, margin=3cm, top=2cm]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{comment}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{mathpartir}
\usepackage{enumitem}
\usepackage{titling}
\usepackage{amsthm}

% Title formatting
\pretitle{\centering\LARGE\bfseries\vspace{0em}}
\posttitle{\par\vspace{1em}}

\preauthor{\centering\large}
\postauthor{\par\vspace{1em}}

\predate{\centering\small}
\postdate{\par}


\setlength{\parindent}{0pt} % no indend automatically everywhere

\title{Small step semantics for arithmetic expressions in Lean}
\author{Sonja Joost}
\date{} % empty date



\begin{document}
% theorem environments
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\maketitle
In this document we will define small step rules for the datatype defining arithmetic expressions in \texttt{Test.lean}. After that, we will show that the \texttt{eval} function defined in Lean corresponds to the defined small step rules. %The proof are paper-proofs, but also implemented in Lean.

\section{Rules}
The datatype is defined as 
\[
e ::= \operatorname{const}(q) \mid \operatorname{var}(x) \mid \operatorname{add}(e_1,e_2) \mid \operatorname{sub}(e_1,e_2) \mid \operatorname{mul}(e_1,e_2) \mid \operatorname{div}(e_1,e_2),\qquad q\in\mathbb{Q},~x\in\text{String}.
\]
In the following we abbreviate constants with values. A value is a constant: $v ::= \operatorname{const}(q)$.

An \emph{environment} $\Gamma : \text{Var} \rightharpoonup \mathbb{Q}$ maps variables to rationals. We write $\Gamma(x)=q$ if the variable $x$ is bound to the value $q$ and $\Gamma(x)=\bot$ if unbound.



Small-step now depends on $\Gamma$: $\Gamma\vdash e \to e'$. Evaluation order is left-to-right (eager evaluation).

Congruence (context) rules:
\begin{mathpar}
\inferrule*[right=E-AddL]{\Gamma\vdash e_1 \to e_1'}{\Gamma\vdash \operatorname{add}(e_1,e_2) \to \operatorname{add}(e_1',e_2)}
\and
\inferrule*[right=E-AddR]{v \text{ value} \\ \Gamma\vdash e_2 \to e_2'}{\Gamma\vdash \operatorname{add}(v,e_2) \to \operatorname{add}(v,e_2')}\\
\inferrule*[right=E-SubL]{\Gamma\vdash e_1 \to e_1'}{\Gamma\vdash \operatorname{sub}(e_1,e_2) \to \operatorname{sub}(e_1',e_2)}
\and
\inferrule*[right=E-SubR]{v \text{ value} \\ \Gamma\vdash e_2 \to e_2'}{\Gamma\vdash \operatorname{sub}(v,e_2) \to \operatorname{sub}(v,e_2')}\\
\inferrule*[right=E-MulL]{\Gamma\vdash e_1 \to e_1'}{\Gamma\vdash \operatorname{mul}(e_1,e_2) \to \operatorname{mul}(e_1',e_2)}
\and
\inferrule*[right=E-MulR]{v \text{ value} \\ \Gamma\vdash e_2 \to e_2'}{\Gamma\vdash \operatorname{mul}(v,e_2) \to \operatorname{mul}(v,e_2')}\\
\inferrule*[right=E-DivL]{\Gamma\vdash e_1 \to e_1'}{\Gamma\vdash \operatorname{div}(e_1,e_2) \to \operatorname{div}(e_1',e_2)}
\and
\inferrule*[right=E-DivR]{v \text{ value} \\ \Gamma\vdash e_2 \to e_2'}{\Gamma\vdash \operatorname{div}(v,e_2) \to \operatorname{div}(v,e_2')}
\end{mathpar}

Lookup and computation rules:
\begin{mathpar}
\inferrule*[right=E-Var]{\Gamma(x)=q}{\Gamma\vdash \operatorname{var}(x) \to \operatorname{const}(q)}\\
\inferrule*[right=E-Add]{~}{\Gamma\vdash \operatorname{add}(\operatorname{const}(q_1),\operatorname{const}(q_2)) \to \operatorname{const}(q_1+q_2)}
\and
\inferrule*[right=E-Sub]{~}{\Gamma\vdash \operatorname{sub}(\operatorname{const}(q_1),\operatorname{const}(q_2)) \to \operatorname{const}(q_1-q_2)}\\
\inferrule*[right=E-Mul]{~}{\Gamma\vdash \operatorname{mul}(\operatorname{const}(q_1),\operatorname{const}(q_2)) \to \operatorname{const}(q_1\cdot q_2)}
\and
\inferrule*[right=E-Div]{q_2\neq 0}{\Gamma\vdash \operatorname{div}(\operatorname{const}(q_1),\operatorname{const}(q_2)) \to \operatorname{const}\!\left(\dfrac{q_1}{q_2}\right)}
\end{mathpar}

No rule applies for division by zero or an unbound variable, so those forms are stuck. This corresponds to the evaluation function that would return none. 

Write $\Gamma\vdash e \to^{\!*} e'$ for the reflexive–transitive closure.

\section{Helper lemmas}
Define $e \downarrow_{\Gamma} q :\iff \operatorname{eval}(e,\Gamma)=\text{some }q$. % and $e \downarrow\!\downarrow_{\Gamma} :\iff \operatorname{eval}(e,\Gamma)=\text{none}$.

\begin{lemma}[Canonical forms]
If $v$ is a value then $v=\operatorname{const}(q)$.
\end{lemma}

\begin{lemma}[Terminal Normal forms]
If $e$ is $\Gamma$-normal (no $e'$ with $\Gamma\vdash e\to e'$) and a value or \emph{cannot reach a compound expression through any steps}, then exactly one of:
\begin{enumerate}[label=\alph*)]
\item $e=\operatorname{const}(q)$;
\item $e=\operatorname{div}(\operatorname{const}(q_1),\operatorname{const}(0))$;
\item $e=\operatorname{var}(x)$ with $\Gamma(x)=\bot$.
\end{enumerate}
These are the \emph{terminal} normal forms. Note that stuck expressions may also have compound structure (e.g., $\operatorname{add}(n,e)$ where $n$ is a terminal stuck form). %, but by the multi-step relation, any stuck expression eventually reaches or contains a terminal stuck form.
\end{lemma}

\begin{proof}
We must show both directions: if $e$ is normal then it's one of these forms, and conversely.

\textbf{($\Rightarrow$) If $e$ is $\Gamma$-normal then $e$ is one of (a), (b), (c).}

By structural induction on $e$:

\begin{description}
\item[Const:] $e=\operatorname{const}(q)$. This is form (a).

\item[Var:] $e=\operatorname{var}(x)$. If $\Gamma(x)=q$, then E-Var applies, so $e$ is not normal. Thus $\Gamma(x)=\bot$, giving form (c).

\item[Add:] $e=\operatorname{add}(e_1,e_2)$. For $e$ to be normal:
\begin{itemize}
\item E-AddL requires $e_1$ to step, so $e_1$ must be normal.
\item If $e_1$ is a value (i.e., $e_1=\operatorname{const}(r)$), then E-AddR would apply if $e_2$ steps, so $e_2$ must be normal.
\item If both $e_1=\operatorname{const}(r_1)$ and $e_2=\operatorname{const}(r_2)$, then E-Add applies, contradiction.
\end{itemize}
So we need $e_1$ to be a value and $e_2$ to be a normal non-value, or $e_1$ to be a normal non-value. By IH, normal forms are only (a), (b), (c). Forms (b) and (c) are not values. But if $e$ has a compound structure like $\operatorname{add}(\ldots)$, it cannot match any of (a), (b), (c), which are all atomic. This is a contradiction. Therefore, $e$ cannot have the form $\operatorname{add}(e_1,e_2)$ and be a normal form.

\item[Sub/Mul:] Similar reasoning: compound expressions cannot be normal forms.

\item[Div:] $e=\operatorname{div}(e_1,e_2)$. For $e$ to be normal, $e_1$ cannot step (else E-DivL applies). If $e_1=\operatorname{const}(r_1)$, then $e_2$ cannot step (else E-DivR applies). If $e_2=\operatorname{const}(r_2)$ with $r_2\neq 0$, then E-Div applies. So the only way $\operatorname{div}(\operatorname{const}(r_1),\operatorname{const}(r_2))$ is normal is if $r_2=0$, giving form (b). Any other structure for $\operatorname{div}(e_1,e_2)$ would be compound and not match (a), (b), or (c).
\end{description}

\textbf{($\Leftarrow$) Each of (a), (b), (c) is $\Gamma$-normal.}

\begin{itemize}
\item Form (a): $e=\operatorname{const}(q)$. No rule has a constant as the source of a step.
\item Form (b): $e=\operatorname{div}(\operatorname{const}(q_1),\operatorname{const}(0))$. The only applicable rule would be E-Div, but it requires $q_2\neq 0$, which fails.
\item Form (c): $e=\operatorname{var}(x)$ with $\Gamma(x)=\bot$. E-Var requires $\Gamma(x)=q$, which fails.
\end{itemize}

Thus the three forms are exactly the normal forms.
\end{proof}



\subsection*{Auxiliary multi-step lemmas}
We use the reflexive--transitive closure $\Gamma\vdash e\to^{\!*}e'$ (written in Lean as the inductive predicate `Steps env e e'`). The following lemmas mirror the Lean helper lemmas.

\begin{lemma}[Concatenation (Lean: \texttt{Steps.append}).] 
    If $\Gamma\vdash e\to^{\!*}e_1$ and $\Gamma\vdash e_1\to^{\!*}e_2$ then $\Gamma\vdash e\to^{\!*}e_2$. 
\end{lemma}

\begin{proof}
Let $h_1 : \Gamma\vdash e\to^{\!*}e_1$ and $h_2 : \Gamma\vdash e_1\to^{\!*}e_2$. We proceed by induction on $h_2$.

\textbf{Base case:} $h_2$ is the reflexive rule, so $e_1 = e_2$. Then $\Gamma\vdash e\to^{\!*}e_1 = e_2$ by $h_1$.

\textbf{Inductive case:} $h_2$ is of the form $\Gamma\vdash e_1\to^{\!*}e'$ followed by a single step $\Gamma\vdash e'\to e_2$ for some intermediate expression $e'$. 

By the induction hypothesis applied to $h_1$ and $\Gamma\vdash e_1\to^{\!*}e'$, we obtain $\Gamma\vdash e\to^{\!*}e'$.

Now we apply the trans constructor to combine $\Gamma\vdash e\to^{\!*}e'$ with the single step $\Gamma\vdash e'\to e_2$ to get $\Gamma\vdash e\to^{\!*}e_2$.
\end{proof}

\begin{lemma}[Context lifting (Lean: \texttt{Steps.liftCtx}).] 
    Let $C[\_]$ be a one-hole context formed by adding a fixed surrounding constructor (e.g. $C[t]=\operatorname{add}(t,e_2)$). Suppose every single step lifts through $C$: whenever $\Gamma\vdash t\to t'$ then $\Gamma\vdash C[t]\to C[t']$. Then if $\Gamma\vdash e\to^{\!*} e'$ we have $\Gamma\vdash C[e]\to^{\!*}C[e']$. 
\end{lemma}

\begin{proof}
Let $h : \Gamma\vdash e\to^{\!*}e'$ and assume the lifting property: for all $x, y$, if $\Gamma\vdash x\to y$ then $\Gamma\vdash C[x]\to C[y]$.

We proceed by induction on $h$.

\textbf{Base case:} $h$ is the reflexive rule, so $e = e'$. Then $C[e] = C[e']$ and $\Gamma\vdash C[e]\to^{\!*}C[e']$ by reflexivity.

\textbf{Inductive case:} $h$ is of the form $\Gamma\vdash e\to^{\!*}e''$ followed by a single step $\Gamma\vdash e''\to e'$ for some intermediate expression $e''$.

By the induction hypothesis applied to $\Gamma\vdash e\to^{\!*}e''$, we obtain $\Gamma\vdash C[e]\to^{\!*}C[e'']$.

By the lifting property applied to the single step $\Gamma\vdash e''\to e'$, we obtain $\Gamma\vdash C[e'']\to C[e']$.

We apply the trans constructor to combine $\Gamma\vdash C[e]\to^{\!*}C[e'']$ with $\Gamma\vdash C[e'']\to C[e']$ to get $\Gamma\vdash C[e]\to^{\!*}C[e']$.
\end{proof}


\begin{lemma}[Reduction lemmas (Lean: \texttt{Steps.reduceAdd}, \texttt{Steps.reduceSub}, \texttt{Steps.reduceMul}, \texttt{Steps.reduceDiv}.).] For each arithmetic operator we derive a multi-step reduction once its operands are reduced to constants:
\begin{align*}
&\text{Add: }\Gamma\vdash e_1\to^{\!*}\operatorname{const}(r_1),\ \Gamma\vdash e_2\to^{\!*}\operatorname{const}(r_2) \Rightarrow \Gamma\vdash \operatorname{add}(e_1,e_2)\to^{\!*}\operatorname{const}(r_1+r_2).\\
&\text{Sub: }\cdots \Rightarrow \Gamma\vdash \operatorname{sub}(e_1,e_2)\to^{\!*}\operatorname{const}(r_1-r_2).\\
&\text{Mul: }\cdots \Rightarrow \Gamma\vdash \operatorname{mul}(e_1,e_2)\to^{\!*}\operatorname{const}(r_1\cdot r_2).\\
&\text{Div: }r_2\neq 0,\ \cdots \Rightarrow \Gamma\vdash \operatorname{div}(e_1,e_2)\to^{\!*}\operatorname{const}(r_1/r_2).
\end{align*}
\end{lemma}

\begin{proof}[Proof (Add)]
Let $s_1 : \Gamma\vdash e_1\to^{\!*}\operatorname{const}(r_1)$ and $s_2 : \Gamma\vdash e_2\to^{\!*}\operatorname{const}(r_2)$.

We apply context lifting to $s_1$ using $C_L[t]=\operatorname{add}(t,e_2)$ with lifting property E-AddL to obtain:
\[
L : \Gamma\vdash \operatorname{add}(e_1,e_2)\to^{\!*}\operatorname{add}(\operatorname{const}(r_1),e_2).
\]

We apply context lifting to $s_2$ using $C_R[t]=\operatorname{add}(\operatorname{const}(r_1),t)$ with lifting property E-AddR to obtain:
\[
R : \Gamma\vdash \operatorname{add}(\operatorname{const}(r_1),e_2)\to^{\!*}\operatorname{add}(\operatorname{const}(r_1),\operatorname{const}(r_2)).
\]

By rule E-Add, we have $\Gamma\vdash \operatorname{add}(\operatorname{const}(r_1),\operatorname{const}(r_2))\to \operatorname{const}(r_1+r_2)$. We extend $R$ with this step using trans to get:
\[
R' : \Gamma\vdash \operatorname{add}(\operatorname{const}(r_1),e_2)\to^{\!*}\operatorname{const}(r_1+r_2).
\]

Applying concatenation to $L$ and $R'$ yields $\Gamma\vdash \operatorname{add}(e_1,e_2)\to^{\!*}\operatorname{const}(r_1+r_2)$.
\end{proof}

\emph{Proof (Sub/Mul).} Identical reasoning to addition using E-SubL/E-SubR/E-Sub and E-MulL/E-MulR/E-Mul respectively.

\begin{proof}[Proof (Div)]
Let $nz : r_2\neq 0$, $s_1 : \Gamma\vdash e_1\to^{\!*}\operatorname{const}(r_1)$, and $s_2 : \Gamma\vdash e_2\to^{\!*}\operatorname{const}(r_2)$.

We apply context lifting to $s_1$ using $C_L[t]=\operatorname{div}(t,e_2)$ with lifting property E-DivL to obtain:
\[
L : \Gamma\vdash \operatorname{div}(e_1,e_2)\to^{\!*}\operatorname{div}(\operatorname{const}(r_1),e_2).
\]

We apply context lifting to $s_2$ using $C_R[t]=\operatorname{div}(\operatorname{const}(r_1),t)$ with lifting property E-DivR to obtain:
\[
R : \Gamma\vdash \operatorname{div}(\operatorname{const}(r_1),e_2)\to^{\!*}\operatorname{div}(\operatorname{const}(r_1),\operatorname{const}(r_2)).
\]

By rule E-Div with premise $r_2\neq 0$, we have $\Gamma\vdash \operatorname{div}(\operatorname{const}(r_1),\operatorname{const}(r_2))\to \operatorname{const}(r_1/r_2)$. We extend $R$ with this step using trans to get:
\[
R' : \Gamma\vdash \operatorname{div}(\operatorname{const}(r_1),e_2)\to^{\!*}\operatorname{const}(r_1/r_2).
\]

Applying concatenation to $L$ and $R'$ yields $\Gamma\vdash \operatorname{div}(e_1,e_2)\to^{\!*}\operatorname{const}(r_1/r_2)$.
\end{proof}


\newpage
\section{Proofs}

\subsection*{Equivalence}
To show that the evaluation function and the small step semantics agree, we have to show that
\[ e \downarrow_{\Gamma} q \iff \Gamma\vdash e \to^{\!*} \operatorname{const}(q)\qquad \text{and} \qquad e \downarrow\!\downarrow_{\Gamma} \iff \Gamma\vdash e \to^{\!*} n \text{ stuck as above}.\]


\subsection*{Evaluation preservation}
\begin{lemma}[Single-step preserves evaluation (Lean: \texttt{step\_preserves\_eval})]
If $\Gamma\vdash e\to e'$ then $\operatorname{eval}(e,\Gamma)=\operatorname{eval}(e',\Gamma)$.
\end{lemma}
\emph{Proof.} We do (structural) induction on $\Gamma\vdash e\to^{*}e'$. Cases:


\begin{description}
\item[E-Var.] Premise: $\Gamma(x)=q$. Then
\begin{align*}
\operatorname{eval}(\operatorname{var}(x),\Gamma)&=\Gamma[x]?\\
&=\text{some }q\\
&=\operatorname{eval}(\operatorname{const}(q),\Gamma).
\end{align*}
\item [E-AddL.] Premise: $\Gamma\vdash e_1\to e_1'$ and IH gives $\operatorname{eval}(e_1,\Gamma)=\operatorname{eval}(e_1',\Gamma)$. Then
\begin{align*}
\operatorname{eval}(\operatorname{add}(e_1,e_2),\Gamma)
&=\text{do }(\leftarrow \operatorname{eval}(e_1,\Gamma)) + (\leftarrow \operatorname{eval}(e_2,\Gamma))\\
&=\text{do }(\leftarrow \operatorname{eval}(e_1',\Gamma)) + (\leftarrow \operatorname{eval}(e_2,\Gamma))\\
&=\operatorname{eval}(\operatorname{add}(e_1',e_2),\Gamma).
\end{align*}
\item [E-AddR.] Premises: $v$ value and $\Gamma\vdash e_2\to e_2'$. By canonical forms for values, $v=\operatorname{const}(r)$, hence $\operatorname{eval}(v,\Gamma)=\text{some }r$. IH: $\operatorname{eval}(e_2,\Gamma)=\operatorname{eval}(e_2',\Gamma)$. Then
\begin{align*}
\operatorname{eval}(\operatorname{add}(v,e_2),\Gamma)
&=\text{do }(\leftarrow \operatorname{eval}(v,\Gamma)) + (\leftarrow \operatorname{eval}(e_2,\Gamma))\\
&=\text{do }(\leftarrow \text{some }r) + (\leftarrow \operatorname{eval}(e_2,\Gamma))\\
&=\text{do }r + (\leftarrow \operatorname{eval}(e_2,\Gamma))\\
&=\text{do }r + (\leftarrow \operatorname{eval}(e_2',\Gamma))\\
&=\operatorname{eval}(\operatorname{add}(v,e_2'),\Gamma).
\end{align*}
\item [E-Add.] Both sides constants. Then
\begin{align*}
\operatorname{eval}(\operatorname{add}(\operatorname{const}(q_1),\operatorname{const}(q_2)),\Gamma)
&=\text{do }(\leftarrow \text{some }q_1) + (\leftarrow \text{some }q_2)\\
&=\text{some }(q_1+q_2)\\
&=\operatorname{eval}(\operatorname{const}(q_1+q_2),\Gamma).
\end{align*}
\item [E-SubL/E-SubR/E-Sub.] Identical equational reasoning with $-$ in place of $+$.
\item [E-MulL/E-MulR/E-Mul.] Identical equational reasoning with $*$ in place of $+$.
\item [E-DivL.] Premise: $\Gamma\vdash e_1\to e_1'$ and IH gives $\operatorname{eval}(e_1,\Gamma)=\operatorname{eval}(e_1',\Gamma)$. Then
\begin{align*}
\operatorname{eval}(\operatorname{div}(e_1,e_2),\Gamma)
&=\text{do }r_b\leftarrow \operatorname{eval}(e_2,\Gamma);\ \textbf{if }r_b=0\textbf{ then }\text{none}\\
&\qquad\textbf{ else }r_a\leftarrow \operatorname{eval}(e_1,\Gamma);\ \text{some }(r_a/r_b)\\
&=\text{do }r_b\leftarrow \operatorname{eval}(e_2,\Gamma);\ \textbf{if }r_b=0\textbf{ then }\text{none}\\
&\qquad\textbf{ else }r_a\leftarrow \operatorname{eval}(e_1',\Gamma);\ \text{some }(r_a/r_b)\\
&=\operatorname{eval}(\operatorname{div}(e_1',e_2),\Gamma).
\end{align*}
\item [E-DivR.] Premises: $v$ value so $v=\operatorname{const}(r)$ and $\operatorname{eval}(v,\Gamma)=\text{some }r$, and $\Gamma\vdash e_2\to e_2'$ with IH $\operatorname{eval}(e_2,\Gamma)=\operatorname{eval}(e_2',\Gamma)$. Then
\begin{align*}
\operatorname{eval}(\operatorname{div}(v,e_2),\Gamma)
&=\text{do }r_b\leftarrow \operatorname{eval}(e_2,\Gamma);\ \textbf{if }r_b=0\textbf{ then }\text{none}\\
&\qquad\textbf{ else }r_a\leftarrow \operatorname{eval}(v,\Gamma);\ \text{some }(r_a/r_b)\\
&=\text{do }r_b\leftarrow \operatorname{eval}(e_2',\Gamma);\ \textbf{if }r_b=0\textbf{ then }\text{none}\\
&\qquad\textbf{ else }r_a\leftarrow \text{some }r;\ \text{some }(r_a/r_b)\\
&=\operatorname{eval}(\operatorname{div}(v,e_2'),\Gamma).
\end{align*}
\item [E-Div.] Premise: $q_2\neq 0$. Then
\begin{align*}
\operatorname{eval}(\operatorname{div}(\operatorname{const}(q_1),\operatorname{const}(q_2)),\Gamma)
&=\text{do }r_b\leftarrow \text{some }q_2;\\ 
&\textbf{if }r_b=0\textbf{ then }\text{none } \textbf{ else } r_a\leftarrow \text{some }q_1;\ \text{some }(r_a/r_b)\\
&=\text{some }(q_1/q_2) \quad(\text{since }q_2\neq 0)\\
&=\operatorname{eval}(\operatorname{const}(q_1/q_2),\Gamma).
\end{align*}
\end{description}
\qed

\begin{lemma}[Multi-step preserves evaluation (Lean: \texttt{steps\_preserve\_eval})]
If $\Gamma\vdash e\to^{\!*} e'$ then $\operatorname{eval}(e,\Gamma)=\operatorname{eval}(e',\Gamma)$.
\end{lemma}
\emph{Proof.} Induction on the length of the small step derivation. The reflexive case trivial. In the inductive case, by definition of $\to^{*}$ we have that $e\to^{*}e''$ and $e''\to e$. Using the induction hypothesis on $e\to^{*}e''$ we have $\operatorname{eval}(e,\Gamma)=\operatorname{eval}(e'',\Gamma)$. By using Lemma 1 on $e''\to e$ we have $\operatorname{eval}(e'', \Gamma)=\operatorname{eval}(e, \Gamma)$. If we combine both, we get $\operatorname{eval}(e,\Gamma)=\operatorname{eval}(e',\Gamma)$. \qed



\subsection*{Soundness}
\begin{theorem}[Soundness (Lean: \texttt{small\_step\_soundness})]
If $\Gamma\vdash e \to^{\!*} \operatorname{const}(q)$ then $e \downarrow_{\Gamma} q$.
\end{theorem}
\emph{Proof.} By multi-step preservation,
\begin{align*}
\operatorname{eval}(e,\Gamma)&=\operatorname{eval}(\operatorname{const}(q),\Gamma)\\
&=\text{some }q
\end{align*}
by the first clause of the definition of \texttt{eval}. Hence $e \downarrow_{\Gamma} q$. \qed

\newpage
\subsection*{Completeness}

As a reminder for the upcoming proof, those are the definitions for the evaluation function from \texttt{Test.lean}:
\begin{align*}
&\operatorname{eval}(\operatorname{const}(q),\Gamma)=\text{some }q,\\
&\operatorname{eval}(\operatorname{var}(x),\Gamma)=\Gamma[x]?,\\
&\operatorname{eval}(\operatorname{add}(a,b),\Gamma)=\text{do }(\leftarrow \operatorname{eval}(a,\Gamma)) + (\leftarrow \operatorname{eval}(b,\Gamma)),\\
&\operatorname{eval}(\operatorname{sub}(a,b),\Gamma)=\text{do }(\leftarrow \operatorname{eval}(a,\Gamma)) - (\leftarrow \operatorname{eval}(b,\Gamma)),\\
&\operatorname{eval}(\operatorname{mul}(a,b),\Gamma)=\text{do }(\leftarrow \operatorname{eval}(a,\Gamma)) * (\leftarrow \operatorname{eval}(b,\Gamma)),\\
&\operatorname{eval}(\operatorname{div}(a,b),\Gamma)=\text{do }r_b\leftarrow \operatorname{eval}(b,\Gamma);\ \textbf{if }r_b=0\textbf{ then }\text{none}\textbf{ else }r_a\leftarrow \operatorname{eval}(a,\Gamma);\ \text{some }(r_a/r_b).
\end{align*}

\begin{theorem}[Completeness (Lean: \texttt{eval\_some\_implies\_steps\_to\_const})]
If $e \downarrow_{\Gamma} \operatorname{some}q$ then $\Gamma\vdash e \to^{\!*} \operatorname{const}(q)$.
\end{theorem}
\emph{Proof.} By structural induction on $e$:
\begin{description}
\item[Const.] We have $e = \operatorname{const}(r)$ for some $r\in \mathbb{Q}$. Then, $\operatorname{eval}(\operatorname{const}(r),\Gamma)=\text{some }q$. By definition of eval, we have $r = q$. By taking zero steps we have $\Gamma \vdash \operatorname{const}(r) \to^{*} \operatorname{const}(q)$.

\item[Var.] We have $e = \operatorname{var}(x)$ for some $x\in \text{String}$. Then, $\operatorname{eval}(\operatorname{var}(x),\Gamma)=\text{some }q$. By definition of eval we have $\Gamma[x]?=\text{some }q$ and thus $\Gamma(x) = q$. By applying E-Var once we get $\Gamma\vdash \operatorname{var}(x)\to^{*}\text{const }q$.

\item[Add.] We have $e = \operatorname{add}(e_1,e_2)$.

Our assumption
\begin{align*}
\operatorname{eval}(\operatorname{add}(e_1,e_2),\Gamma)=\text{some }q
\end{align*}
unfolds to
\begin{align*}
\text{do }(\leftarrow \operatorname{eval}(e_1,\Gamma)) + (\leftarrow \operatorname{eval}(e_2,\Gamma))&=\text{some }q,
\end{align*}
which is possible iff there exist $r_1,r_2\in \mathbb{Q}$ with
\begin{align*}
\operatorname{eval}(e_1,\Gamma)=\text{some }r_1,\quad \operatorname{eval}(e_2,\Gamma)=\text{some }r_2,\quad q=r_1+r_2.
\end{align*}
We apply the induction hypothesis to both eval-expressions to obtain $\Gamma\vdash e_1\to^{\!*}\operatorname{const}(r_1)$ and $\Gamma\vdash e_2\to^{\!*}\operatorname{const}(r_2)$. We apply the reduction lemma to obtain
$\Gamma\vdash \operatorname{add}(e_1,e_2)\to^{\!*}\operatorname{const}(r_1+r_2)$.
\item[Sub/Mul.] Identical unpacking of the monadic definition with $-$ or $*$, yielding $q=r_1-r_2$ or $q=r_1*r_2$ by applying the respective reduction lemma.

\item[Div.] We have $e = \operatorname{div}(e_1,e_2)$. 

Our assumption
\begin{align*}
\operatorname{eval}(\operatorname{div}(e_1,e_2),\Gamma)=\text{some }q
\end{align*}
unfolds to
\begin{align*}
\text{do }r_2\leftarrow \operatorname{eval}(e_2,\Gamma);\ \textbf{if }r_2=0\textbf{ then }\text{none}\textbf{ else }r_1\leftarrow \operatorname{eval}(e_1,\Gamma);\ \text{some }(r_1/r_2)=\text{some }q,
\end{align*}
which is possible iff there exist $r_1,r_2$ with
\begin{align*}
\operatorname{eval}(e_2,\Gamma)=\text{some }r_2,\ r_2\neq 0,\ \operatorname{eval}(e_1,\Gamma)=\text{some }r_1,\ q=r_1/r_2.
\end{align*}
We apply our induction hypothesis to both evaluations to obtain $\Gamma\vdash e_1\to^{\!*}\operatorname{const}(r_1)$ and $\Gamma\vdash e_2\to^{\!*}\operatorname{const}(r_2)$, then the division reduction lemma (using $r_2\neq 0$) yields $\operatorname{div}(e_1, e_2)\to^{*}\operatorname{const}(r_1/r_2)$.
\end{description}
\qed

\newpage
\subsection*{Failure and stuckness}

We say an expression $e$ is \emph{stuck} if it cannot take a step: there is no $e'$ with $\Gamma\vdash e\to e'$. This includes both terminal stuck forms and compound expressions containing them (e.g., $\operatorname{add}(\operatorname{var}(x),e_2)$ where $\Gamma(x)=\bot$).

An expression $e$ \emph{reaches a terminal stuck form} iff $\Gamma \vdash e \to^{\!*} n$, where $n$ is one of the two terminal stuck forms: $\operatorname{div}(\operatorname{const}(q_1),\operatorname{const}(0))$ or $\operatorname{var}(x)$ with $\Gamma(x)=\bot$.
\begin{lemma}
$\operatorname{eval}(e,\Gamma)=\text{none}$ iff $\Gamma\vdash e \to^{\!*} n$ where $n$ is stuck.
\end{lemma}

\begin{proof}
We prove both directions.

\paragraph{($\Rightarrow$) If $\operatorname{eval}(e,\Gamma)=\text{none}$ then $\Gamma\vdash e \to^{\!*} n$ where $n$ is stuck.}

By structural induction on $e$.

\begin{description}
\item[Const.] We have $e=\operatorname{const}(q)$. Then $\operatorname{eval}(\operatorname{const}(q),\Gamma)=\text{some }q\neq\text{none}$, contradiction.

\item[Var.] We have $e=\operatorname{var}(x)$. Then $\operatorname{eval}(\operatorname{var}(x),\Gamma)=\Gamma[x]?=\text{none}$ means $\Gamma(x)=\bot$. We have $\Gamma\vdash e\to^{\!*}e$ by zero steps (reflexivity). The expression $\operatorname{var}(x)$ with $\Gamma(x)=\bot$ is stuck: no rule applies since E-Var requires $\Gamma(x)=q$ for some $q$.

\item[Add.] We have $e=\operatorname{add}(e_1,e_2)$. The monadic definition gives
\[
\operatorname{eval}(\operatorname{add}(e_1,e_2),\Gamma)=\text{do }(\leftarrow \operatorname{eval}(e_1,\Gamma)) + (\leftarrow \operatorname{eval}(e_2,\Gamma))=\text{none}.
\]
This is possible iff $\operatorname{eval}(e_1,\Gamma)=\text{none}$ or $\operatorname{eval}(e_2,\Gamma)=\text{none}$ (or both).

\emph{Subcase} $\operatorname{eval}(e_1,\Gamma)=\text{none}$. By IH, $\Gamma\vdash e_1\to^{\!*}n_1$ where $n_1$ is stuck. By context lifting (using E-AddL repeatedly), $\Gamma\vdash \operatorname{add}(e_1,e_2)\to^{\!*}\operatorname{add}(n_1,e_2)$. This compound expression is stuck: E-AddL cannot apply (since $n_1$ is stuck), and E-AddR cannot apply (since $n_1$ is not a value—it's either $\operatorname{div}(\operatorname{const}(q_1),\operatorname{const}(0))$ or $\operatorname{var}(x)$ with $\Gamma(x)=\bot$, neither of which is a value). E-Add cannot apply since $n_1$ is not a constant.

\emph{Subcase} $\operatorname{eval}(e_1,\Gamma)=\text{some }r_1$ and $\operatorname{eval}(e_2,\Gamma)=\text{none}$. By completeness, $\Gamma\vdash e_1\to^{\!*}\operatorname{const}(r_1)$. By IH on $e_2$, $\Gamma\vdash e_2\to^{\!*}n_2$ where $n_2$ is stuck. Context lifting gives $\Gamma\vdash \operatorname{add}(e_1,e_2)\to^{\!*}\operatorname{add}(\operatorname{const}(r_1),e_2)\to^{\!*}\operatorname{add}(\operatorname{const}(r_1),n_2)$. This is stuck: E-Add requires both arguments to be constants, but $n_2$ is not a constant; E-AddR requires $n_2$ to step, but $n_2$ is stuck.

\item[Sub/Mul.] We have $e=\operatorname{sub}(e_1,e_2)$, $e=\operatorname{mul}(e_1,e_2)$. Identical reasoning to addition using E-SubL/E-SubR/E-Sub and E-MulL/E-MulR/E-Mul respectively.

\item[Div.] We have $e=\operatorname{div}(e_1,e_2)$. The definition is
\[
\operatorname{eval}(\operatorname{div}(e_1,e_2),\Gamma)=\text{do }r_2\leftarrow \operatorname{eval}(e_2,\Gamma);\ \textbf{if }r_2=0\textbf{ then }\text{none}\textbf{ else }r_1\leftarrow \operatorname{eval}(e_1,\Gamma);\ \text{some }(r_1/r_2).
\]
This equals none iff:
\begin{itemize}
\item $\operatorname{eval}(e_2,\Gamma)=\text{none}$, or
\item $\operatorname{eval}(e_2,\Gamma)=\text{some }r_2$ with $r_2=0$ and any outcome for $e_1$, or
\item $\operatorname{eval}(e_2,\Gamma)=\text{some }r_2$ with $r_2\neq 0$ and $\operatorname{eval}(e_1,\Gamma)=\text{none}$.
\end{itemize}

\emph{Subcase} $\operatorname{eval}(e_2,\Gamma)=\text{none}$. By IH, $\Gamma\vdash e_2\to^{\!*}n_2$ stuck. Context lifting gives $\Gamma\vdash \operatorname{div}(e_1,e_2)\to^{\!*}\operatorname{div}(e_1,n_2)$, which is stuck by similar reasoning to addition.

\emph{Subcase} $\operatorname{eval}(e_2,\Gamma)=\text{some }0$ and $\operatorname{eval}(e_1,\Gamma)=\text{some }r_1$. By completeness, $\Gamma\vdash e_1\to^{\!*}\operatorname{const}(r_1)$ and $\Gamma\vdash e_2\to^{\!*}\operatorname{const}(0)$. Context lifting yields $\Gamma\vdash \operatorname{div}(e_1,e_2)\to^{\!*}\operatorname{div}(\operatorname{const}(r_1),\operatorname{const}(0))$. This is stuck: E-Div requires $q_2\neq 0$, which fails here.

\emph{Subcase} $\operatorname{eval}(e_2,\Gamma)=\text{some }0$ and $\operatorname{eval}(e_1,\Gamma)=\text{none}$. By IH, $\Gamma\vdash e_1\to^{\!*}n_1$ stuck. By completeness on $e_2$, $\Gamma\vdash e_2\to^{\!*}\operatorname{const}(0)$. We reach $\Gamma\vdash \operatorname{div}(e_1,e_2)\to^{\!*}\operatorname{div}(n_1,\operatorname{const}(0))$, which is stuck.

\emph{Subcase} $\operatorname{eval}(e_2,\Gamma)=\text{some }r_2$ with $r_2\neq 0$ and $\operatorname{eval}(e_1,\Gamma)=\text{none}$. By completeness on $e_2$ and IH on $e_1$, we reach $\Gamma\vdash \operatorname{div}(e_1,e_2)\to^{\!*}\operatorname{div}(n_1,\operatorname{const}(r_2))$, which is stuck.
\end{description}

\paragraph{($\Leftarrow$) If $\Gamma\vdash e \to^{\!*} n$ where $n$ is stuck and not a value, then $\operatorname{eval}(e,\Gamma)=\text{none}$.}

By multi-step preservation, $\operatorname{eval}(e,\Gamma)=\operatorname{eval}(n,\Gamma)$. We show $\operatorname{eval}(n,\Gamma)=\text{none}$ by structural induction on $n$.

\textbf{Terminal stuck forms:}

\textbf{Case} $n=\operatorname{var}(x)$ with $\Gamma(x)=\bot$. Then $\operatorname{eval}(\operatorname{var}(x),\Gamma)=\Gamma[x]?=\text{none}$ by definition.

\textbf{Case} $n=\operatorname{div}(\operatorname{const}(q_1),\operatorname{const}(0))$. Then
\[
\operatorname{eval}(n,\Gamma)=\text{do }r_2\leftarrow \text{some }0;\ \textbf{if }r_2=0\textbf{ then }\text{none}\textbf{ else }\cdots=\text{none}.
\]

\textbf{Compound stuck forms:}

\textbf{Case} $n=\operatorname{const}(q)$. Constants are values, contradicting the assumption that $n$ is not a value.

\textbf{Case} $n=\operatorname{add}(n_1,n_2)$ stuck. Since $n$ is stuck, E-AddL cannot apply, so $n_1$ must be stuck. By IH, $\operatorname{eval}(n_1,\Gamma)=\text{none}$. Then
\[
\operatorname{eval}(\operatorname{add}(n_1,n_2),\Gamma)=\text{do }(\leftarrow \operatorname{eval}(n_1,\Gamma)) + (\leftarrow \operatorname{eval}(n_2,\Gamma))=\text{do }(\leftarrow \text{none}) + \cdots=\text{none}.
\]

\textbf{Case} $n=\operatorname{sub}(n_1,n_2)$ or $n=\operatorname{mul}(n_1,n_2)$ stuck. Identical reasoning: the left operand must be stuck, so evaluation returns none.

\textbf{Case} $n=\operatorname{div}(n_1,n_2)$ stuck. Since $n$ is stuck, either:
\begin{itemize}
\item $n_2$ is stuck (E-DivL fails), so by IH $\operatorname{eval}(n_2,\Gamma)=\text{none}$, giving
\[
\operatorname{eval}(\operatorname{div}(n_1,n_2),\Gamma)=\text{do }r_2\leftarrow \operatorname{eval}(n_2,\Gamma);\cdots=\text{do }r_2\leftarrow \text{none};\cdots=\text{none}.
\]
\item $n_2=\operatorname{const}(0)$ and $n_1$ stuck or $n_1=\operatorname{const}(r_1)$. If $n_1$ stuck, then $\operatorname{eval}(n_1,\Gamma)=\text{none}$ by IH, and evaluation fails. If $n_1=\operatorname{const}(r_1)$, then
\[
\operatorname{eval}(\operatorname{div}(\operatorname{const}(r_1),\operatorname{const}(0)),\Gamma)=\text{do }r_2\leftarrow \text{some }0;\ \textbf{if }r_2=0\textbf{ then }\text{none}\cdots=\text{none}.
\]
\end{itemize}

Thus every stuck non-value evaluates to none.
\end{proof}



\end{document}